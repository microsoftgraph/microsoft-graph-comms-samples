<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Graph Core and Communications SDK Concepts </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Graph Core and Communications SDK Concepts ">
    <meta name="generator" content="docfx 2.39.2.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../resources/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="graph-core-and-communications-sdk-concepts">Graph Core and Communications SDK Concepts</h1>

<p>The Graph signaling SDK is quite flexible and can run in multiple environments, and support both stateful and stateless architectures.  It can run on <a href="https://github.com/microsoftgraph/microsoft-graph-comms-samples/tree/master/Samples/V1.0Samples/LocalMediaSamples/AudioVideoPlaybackBot">Azure Cloud Service</a>, <a href="https://github.com/microsoftgraph/microsoft-graph-comms-samples/tree/master/Samples/V1.0Samples/LocalMediaSamples/HueBot">Azure Service Fabric</a>, and <a href="https://github.com/microsoftgraph/microsoft-graph-comms-samples/tree/master/Samples/V1.0Samples/RemoteMediaSamples/IncidentBot">Azure App Service</a>.  Furthermore, because the SDK supports both <a href="https://blogs.msdn.microsoft.com/dotnet/2015/11/30/net-framework-4-6-1-is-now-available/">.net framework 4.6.1+</a> and <a href="https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md">netstandard 2.0</a> it is <a href="https://docs.microsoft.com/en-us/dotnet/core/linux-prerequisites?tabs=netcore2x">cross platform</a>.</p>
<p>This article describes the key concepts in order to effectively utilize the Graph Core SDK and the Graph Communications SDK including the Calling SDK.</p>
<h2 id="graph-communications-core-sdk">Graph Communications Core SDK</h2>
<p>The <a href="https://docs.microsoft.com/en-us/graph/sdks/create-client?tabs=CS">GraphServiceClient</a> object is the entry point to the Graph Core SDK. The majority of the Graph Core SDK is automatically generated by the Graph SDK generator using the OData resource model. It reflects the REST-ful wire protocol provided by the Graph Communications service.</p>
<h2 id="graph-communications-stateful-sdk-and-client-builder">Graph Communications Stateful SDK and Client Builder</h2>
<p>The <a class="xref" href="../client/Microsoft.Graph.Communications.Client.ICommunicationsClient.html">ICommunicationsClient</a> object is the entry point to the Graph Communications SDK and the Calling SDK.  This SDK is designed for stateful services and provides additional support on top of the Graph Core SDK for resource state management and media management. The <a class="xref" href="../client/Microsoft.Graph.Communications.Client.ICommunicationsClientBuilder.html">ICommunicationsClientBuilder</a> is the object used to construct a new <code>ICommunicationsClient</code> with the desired settings.</p>
<p>Building media bots has additional considerations which are further outlined in the <a href="../calls_media/index.html">media section</a>.</p>
<h3 id="notification-dispatching">Notification Dispatching</h3>
<p>Notifications for root collections, such as the <code>ICallCollection</code> generated by <code>ICommunicationsClient.Calls()</code>, are handled in a single queue.  Any root resource, such as the <code>ICall</code>, that has been added to the root collection is given it&#39;s own queue.  Any child resources, of the root resource, such as the <code>ICallParticipant</code> use the same queue as the root resource.</p>
<p>Each queue will delivered event callbacks to the developer sequentially.  The SDK will wait to deliver the next event callbacks until all the callbacks for the current event have been processed.  This has been done as to help developers avoid concurrency issues and will in the future support resource versioning and jitter buffers.</p>
<div class="IMPORTANT"><h5>Important</h5><p>It is important for all event handlers to be non-blocking, and any long running operations need to be offloaded to another thread.  Long running operations in any event will block further operations from being raised for the given resource.</p>
</div>
<h3 id="example-outgoing-calls">Example Outgoing Calls</h3>
<p>To illustrate functionality of the Graph Communications Calling SDK, the below examples demonstrate 2 common scenarios: how to make an outbound call to a Microsoft Teams user and how to join an existing Microsoft Teams meeting.</p>
<h4 id="making-an-outbound-call">Making an Outbound Call</h4>
<p>Assuming a bot has been properly registered and deployed, the <code>ICommunicationsClient</code> configured and built.</p>
<p>The bot needs to create the <a class="xref" href="https://github.com/microsoftgraph/msgraph-sdk-dotnet/blob/dev/src/Microsoft.Graph/Models/Generated/Call.cs">Call</a> object with the corresponding parameters and pass the object to the <a class="xref" href="../calls/Microsoft.Graph.Communications.Calls.CallCollectionExtensions.html#Microsoft_Graph_Communications_Calls_CallCollectionExtensions_AddAsync_Microsoft_Graph_Communications_Calls_ICallCollection_Microsoft_Graph_Communications_Calls_JoinMeetingParameters_System_Guid_System_Threading_CancellationToken_">CallCollectionExtensions.AddAsync</a> method as follows:</p>
<pre><code class="lang-cs">Call callResource = new Call
{
  Subject = &quot;**Subject**&quot;,
  Targets = new List&lt;InvitationParticipantInfo&gt;
  {
    new InvitationParticipantInfo
    {
      Identity = new IdentitySet
      {
        User = new Identity
        {
          Id = &quot;**Target&#39;s AAD ObjectId GUID**&quot;
        },
      },
    }
  },
  TenantId = &quot;**The id of the tenant that will host the meeting**&quot;
};

IMediaSession mediaSession = this.Client.CreateMediaSession(**media session settings**);

ICall call = await this.Client.Calls().AddAsync(callResource, mediaSession);
</code></pre><p>SDK will store the state of the call in memory after calling <code>AddAsync</code>. The returned <code>call</code> object above contains the call Id set by the service.</p>
<h4 id="making-an-outbound-call-to-join-an-existing-microsoft-teams-meeting">Making an Outbound Call to Join an Existing Microsoft Teams Meeting</h4>
<p>The above example shows how to create an outbound call to single or multiple participants and create a new conversation. If the bot needs to join an existing conversation, the SDK provides an overload of AddAsync that takes <a class="xref" href="../calls/Microsoft.Graph.Communications.Calls.JoinMeetingParameters.html">JoinMeetingParameters</a> as input.</p>
<p>The bot needs to create the <a class="xref" href="../calls/Microsoft.Graph.Communications.Calls.JoinMeetingParameters.html">JoinMeetingParameters</a> object with the corresponding meeting parameters and pass the object to the <a class="xref" href="../calls/Microsoft.Graph.Communications.Calls.CallCollectionExtensions.html#Microsoft_Graph_Communications_Calls_CallCollectionExtensions_AddAsync_Microsoft_Graph_Communications_Calls_ICallCollection_Microsoft_Graph_Communications_Calls_JoinMeetingParameters_System_Guid_System_Threading_CancellationToken_">CallCollectionExtensions.AddAsync</a> method as follows:</p>
<pre><code class="lang-cs">ChatInfo chatInfo = new ChatInfo
{
  MessageId = &quot;**Message Id**&quot;,
  ThreadId = &quot;**Thread Id**&quot;,
  ReplyChainMessageId = &quot;**Reply Chain Message Id**&quot;
};

OrganizerMeetingInfo meetingInfo = new OrganizerMeetingInfo
{
  Organizer = new IdentitySet
  {
    User = new Identity
    {
      Id = &quot;**Meeting Organizer&#39;s AAD ObjectId GUID**&quot;
    },
  }
};

meetingInfo.Organizer.User.SetTenantId(&quot;**TenantId Guid**&quot;);

IMediaSession mediaSession = this.Client.CreateMediaSession(**media session settings**);

JoinMeetingParameters joinCallParameters = new JoinMeetingParameters(
  chatInfo,
  meetingInfo,
  mediaSession);

ICall call = await this.Client.Calls().AddAsync(joinCallParameters);
</code></pre><p>SDK will store the state of the call in memory after calling <code>AddAsync</code>. The returned <code>call</code> object above contains the callId set by the service.</p>
<h3 id="example-incoming-calls">Example Incoming Calls</h3>
<p>Any time another user or bot places a call to your bot, you will receive a notification to the global application endpoint specified when registering your bot.  Incoming call scenarios are supported with both Service Hosted Media and App Hosted Media configurations.</p>
<div class="IMPORTANT"><h5>Important</h5><p>For all incoming call scenarios, the initial incoming call notification will still be received using the BotBuilder protocol.  The Graph SDK automatically returns 204 No Content to the initial notification to invoke the new Graph protocol.</p>
</div>
<h4 id="answering-incoming-call-with-application-hosted-media">Answering incoming call with application hosted media</h4>
<p>First, subscribe to incoming calls.</p>
<pre><code class="lang-cs">this.Client.Calls().OnIncoming += this.CallsOnIncoming;
</code></pre><p>When incoming call comes, the bot needs to answer with an <code>IMediaSession</code>.  This can be a media session created using the <a class="xref" href="../calls_media/Microsoft.Graph.Communications.Calls.Media.MediaCommunicationsClientExtensions.html#Microsoft_Graph_Communications_Calls_Media_MediaCommunicationsClientExtensions_CreateMediaSession_Microsoft_Graph_Communications_Client_ICommunicationsClient_Microsoft_Skype_Bots_Media_AudioSocketSettings_Microsoft_Skype_Bots_Media_VideoSocketSettings_Microsoft_Skype_Bots_Media_VideoSocketSettings_Microsoft_Skype_Bots_Media_DataSocketSettings_System_Guid_">ICommunicationsClient.CreateMediaSession()</a> extension or a custom <code>IMediaSession</code>.</p>
<pre><code class="lang-cs">private void CallsOnIncoming(ICallCollection sender, CollectionEventArgs&lt;ICall&gt; collectionEventArgs)
{
  IMediaSession mediaSession = this.Client.CreateMediaSession(
    new AudioSocketSettings
    {
      StreamDirections = StreamDirection.Recvonly,
      SupportedAudioFormat = AudioFormat.Pcm16K
    },
    new VideoSocketSettings
    {
      StreamDirections = StreamDirection.Sendrecv,
      ReceiveColorFormat = VideoColorFormat.NV12,
      SupportedSendVideoFormats = new List&lt;VideoFormat&gt;
      {
        VideoFormat.NV12_720x1280_30Fps,
        VideoFormat.NV12_1280x720_30Fps
      }
    }
  );

  // Run async as not to block subsequent notifications.
  Task.Run(async () =&gt;
  {
    await collectionEventArgs
      .AddedResources
      .FirstOrDefault()
      .AnswerAsync(mediaSession)
      .ConfigureAwait(false);
  });
}
</code></pre><h4 id="answer-incoming-call-with-service-hosted-media">Answer incoming call with service hosted media</h4>
<p>First subscribe to incoming calls.</p>
<pre><code class="lang-cs">this.Client.Calls().OnIncoming += this.CallsOnIncoming;
</code></pre><p>When incoming call comes, the bot will answer with a <code>ServiceHostedMediaConfig</code>.</p>
<pre><code class="lang-cs">private void CallsOnIncoming(ICallCollection sender, CollectionEventArgs&lt;ICall&gt; collectionEventArgs)
{
  // Run async as not to block subsequent notifications.
  Task.Run(async () =&gt;
  {
    await collectionEventArgs
      .AddedResources
      .FirstOrDefault()
      .AnswerAsync(new Modality[] { Modality.Audio })
      .ConfigureAwait(false);
  });
}
</code></pre><h3 id="state-management">State Management</h3>
<p>Graph Communications SDK can be used to store state of all resources in memory.  This has 2 implications:</p>
<ol>
<li>The instance hosting the call needs to be up throughout the lifetime of a call.</li>
<li>Any subsequent asynchronous notifications delivered by the service need to be redirected to the instance hosting the call.</li>
</ol>
<p>Any bot that hosts its own media stack should to be built using the Graph Communications SDK given that the media stream has a requirement that it needs to persist in memory throughout the lifetime of the call.</p>
<p>More details can be found in the <a href="calls/StateManagement.html">State Management</a> article.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (c) <b>Microsoft Corporation</b>. All rights reserved.
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
